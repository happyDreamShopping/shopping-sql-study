# 4장 집약과 자르기

<br>

## 집약

<br>

### 1. 여러 개의 레코드를 한개의 레코드로 집약

<br>

비집약 테이블


<br>

한 사람과 관련된 정보가 여러 개의 레코드에 분산되어 있는 테이블은 한사람의 정보에 접근할 때 where id = 'Jim' 와  select 구문을 사용할 때 당연히 3개의 레코드가 선택됩니다.

<br>

~~~sql
select id, data_1, data_2
from NonAggTbl
where id = 'jim'
and data_type = 'A';
~~~

data_type 이 B, C 도 비슷하게 해야 합니다 ㅠ

==> 한 사람과 관련된 정보가 여러 레코드에 분산되어 있어서 한 사람의 정보를 참조하려면 여러 레코드에 접근해야 합니다

<br>

아래 그림과 같은 레이아웃의 테이블로 만들거나 뷰 테이블을 만들어 사용하는 것이 바람직하다



<br>


case, group by를 사용해보자


group by로 집약했을 때 select 구에 입력할 수 있는 것은 다음과 같은 3가지 뿐입니다.

- 상수
- group by 구에서 사용한 집약 키
- 집약 함수

> 저번에 얘기나온거처럼 mysql은 이런 코드를 입력할 수 있게 기능을 확장했습니다. 하지만 표준에는 없는 내용입니다. 호환되지 않는 내용은 추천하지 않습니다. ==> 집합론의 원리를 위배


<br>



<br>

이 집약 쿼리의 실행계획은 어떻게 될까요? 141page

group by 의 집약 조작에 모두 '해시'라는 알고리즘을 사용하고 있습니다.

<br>


>  oracle 10g 부터는 'SORT GROUP BY' 보다 성능이 개선된 'HASH GROUP BY' 오퍼레이션을 대개 사용한다.

<br>

단, 정렬과 해시 GROUP BY는 모두 메모리를 많이 사용하므로 충분한 워킹 메모리가 확보되지 않으면 스왑이 발생합니다.

<br>

### 2. 합쳐서 하나

제품의 대상 연령별 가격을 관리하는 테이블이 있습니다.


0~100세까지 모든 연령이 가지고 놀 수 있는 제품을 구하라입니다

<br>



<br>


## 자르기


<br>

이름 첫글자를 사용해 특정한 알파벳으로 시작하는 이름을 가진 사람이 몇 명인지 집계

<br>


<br>

이렇게 GROUP BY 구로 잘라 만든 하나하나의 부분 집합을 수학적으로 파티션이라고 부릅니다.

자르기의 기준이 되는 키를 GROUP BY 구와 SELECT 구 모두에 입력하는 것이 포인트입니다.

<br>

2장에서 GROUP BY 구에서 집약 기능을 제외하고 자르는 기능만 남긴 것이 윈도우 함수의 PARTITION BY 구 라고 했습니다.

<br>


<br>

PARTITION BY 구를 사용해도 단순한 필드 이름 뿐 아니라 CASE 식, 계산식을 사용한 기준을 사용할 수 있다는 말입니다.

<br>

GROUP BY 구는 입력 집합을 집약하므로 전혀 다른 레벨의 출력을 반환하지만, 

PARTITION BY 구는 입력에 정보를 추가할 뿐이므로 원본 테이블 정보를 완전히 그대로 유지합니다.
