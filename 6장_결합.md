## 종류

### 1. 크로스 결합
* Cartesian Product 값을 얻을때 사용
* 비용이 많이 들고 쓸일이 없다.


### 2. 내부 결합
* inner join 
* 내부 결합의 결과는 모두 크로스 결합의 부분집합
* '내부' -> '데카르트 곱의 부분 집합' 이란 뜻
  * 그렇다고 크로스 결합으로 결과를 내고 필터링하는 것은 아니야!
 

### 3. 외부 결합
* outer join
* 왼쪽 외부 결합, 오른쪽 외부 결합, 완전 외부 결합
  * 마스터 테이블이 왼쪽이면 `왼쪽 외부 결합`, 오른쪽이면 `오른쪽 외부 결합`
* 마스터 테이블에만 존재하는 키가 있을 때는 제거 않고 결과에 보존
  * '외부' -> 외부 결합이 마스터 테이블의 정보를 모두 보존하기 크로스 결합에도 없는 결과 Null값을 생성함


### 4. 자기 결합
* self join
* 같은 테이블 또는 같은 뷰를 사용해 결합
* 별칭으로 마치 다른 테이블인 것처럼 다룸
  * 물리 레벨에서 보면 같은 테이블이나 논리 레벨에서 보면 서로 다른 테이블의 결합임
```sql
SELECT D1.digit + (D2.digit * 10) AS seq 
FROM Digits D1 CROSS JOIN Digits D2
;
```
<details close>
<summary>more</summary>

```sql
# 100 Rows
0
10
20
30
40
50
60
70
80
90
1
11
21
31
41
51
61
71
81
91
2
12
22
32
42
52
62
72
82
92
3
13
23
33
43
53
63
73
83
93
4
14
24
34
44
54
64
74
84
94
5
15
25
35
45
55
65
75
85
95
6
16
26
36
46
56
66
76
86
96
7
17
27
37
47
57
67
77
87
97
8
18
28
38
48
58
68
78
88
98
9
19
29
39
49
59
69
79
89
99
```

</details>


## 알고리즘
* Optimizer가 가능한 알고리즘은 크게 아래 세 가지임
* Optimizer가 선택할 알고리즘은 데이터 크기, 결합 키의 분산 요인에 의존함
* DBMS 군 또는 버전에 따라 지원하는 알고리즘이 다를 수 있음
  * MySQL: Hash, Sort Merge 사용 안함 

### Nested Loops
* Table_A, Table_B에 대하여 접근되는 레코드 수 = R(A) x R(B)
* 실행 시간 ∝ 접근되는 레코드 수
* 구동 테이블(Table_A)이 작을 수록 성능이 좋아짐 
  * 이중 반복의 외측과 내측의 반복 처리가 비대칭
  * 내부 테이블(Table_B)의 결합 키 필드에 인덱스가 존재
* 이상적인 경우
  * 구동 테이블 레코드 한 개에 내부 테이블 레코드 한 개가 대응하고, 해당 레코드를 내부 테이블의 인덱스를 사용해 찾을 수 있는 경우
  * 접근되는 레코드 수 = R(A) * 2
* **구동 테이블이 작은 Nested Loop + 내부 테이블의 결합 키에 인덱스** 
* 그렇다면 결합 키로 내부 테이블에 접근할 때 히트되는 레코드가 매우 많은 경우는 어떻게 해결해야하나?
  * 점포 테이블(구동) - 주문 테이블(내부) -> 
    * 한 개의 점포에 수백만건, 수천만 건의 레코드가 히트된다면 결국 내부 테이블에 대해 반복 횟수가 많아져서 성능이 낮아짐
    * 주문 테이블의 접근 비용이 현실적이라면 주문 테이블을 구동 테이블로 선택하여, 항상 하나의 레코드로 접근하는 것을 보장

### Hash
* Hash Join은 NL Join이나 Sort Merge Join이 효과적이지 못한 상황을 해결하고자 나온 조인 방식
* 일단 작은 테이블을 스캔하고, 결합 키에 해시 함수를 적용해서 해시값으로 변환  
* 이어서 다른 테이블을 스캔하고, 결합 키가 해시값에 존재하는 지를 확인하는 방법으로 결합을 수행 
* 작은 테이블에서 해시 테이블을 만드는 이유는, 해시 테이블은 워킹 메모리에 저장되므로 효율적
* 결합 테이블로서 해시 테이블을 만들어서 활용하므로 Nested Loops에 비해 메모리를 크게 소모함
* 메모리가 부족하면 저장소를 사용하므로 지연 발생
* 출력되는 해시 값은 등치 결합에만 사용 가능 

#### 유용한 경우
* Nested Loops에서 적당한 구동 테이블이 존재하지 않는 경우 
* 구동 테이블로 사용할만한 작은 테이블은 있지만, 내부 테이블에서 히트되는 레코드 수가 많은 경우
* Nested Loops의 내부 테이블에 인덱스가 존재하지 않는 경우 

#### 주의할 사항
* 초기 해시 테이블 생성 시 사용 메모리양이 많음 -> OLTP 처리 시에는 사용하면 안되! (야간 배치 또는 BI/DWH에 한해 사용)
* Hash 결합은 반드시 양쪽 테이블의 레코드를 전부 일거야 하므로, 테이블 풀 스캔이 사용되는 경우가 많음 -> 테이블 규모가 크면 시간 고려해야해!


### Sort Merge
* 결합 대상 테이블들을 각각 결합 키로 정렬하고, 일치하는 결합 키를 찾아서 결합


### Cross

#### 성능

1. 상황별 최적의 알고리즘이란
2. 실행 계획의 제어와 유의점
